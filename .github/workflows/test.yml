      - name: Act when merged by a reviewer and changes were requested
        if: ${{ fromJson(steps.decision.outputs.result).hasChangesRequested == true && fromJson(steps.decision.outputs.result).mergedByIsReviewer == true }}
        uses: actions/github-script@v7
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // optional import
            const core = (() => { try { return require('@actions/core'); } catch(e){ return null } })();

            // get PR from context
            const pr = context.payload.pull_request;
            const owner = context.repo.owner;
            const repo = context.repo.repo;

            // reconstruct decision result (injected as literal JSON by Actions)
            const decisionResult = JSON.parse('${{ steps.decision.outputs.result }}');

            // safe merged_by login
            const mergedByLogin = pr.merged_by ? pr.merged_by.login : context.actor;

            const title = `Follow-up: PR #${pr.number} — ${pr.title} (merged with prior changes requested)`;
            const reviewersList = (await github.rest.pulls.listReviews({ owner, repo, pull_number: pr.number })).data
              .map(r => r.user && '@' + r.user.login).filter(Boolean).join(', ');

            const body = `A PR that had **changes requested** reviews was merged by @${mergedByLogin}.

**PR:** ${pr.html_url}

**Reviewers who reviewed this PR:** ${reviewersList}

**Why this issue is created**
- The PR previously had one or more "changes requested" reviews; create this issue to track post-merge follow-ups, QA, or backports.

**Action items**
- [ ] Verify runtime/test behavior on integration environment
- [ ] Backport or patch if needed
- [ ] Notify stakeholders / update docs

_This issue was created automatically by a workflow._`;

            // Prevent duplicate: search open issues mentioning this PR URL
            const q = `repo:${owner}/${repo} in:body "${pr.html_url}" state:open`;
            const searchRes = await github.rest.search.issuesAndPullRequests({ q });

            if (searchRes.data.total_count > 0) {
              (core && core.info) ? core.info('An open issue referencing this PR already exists — skipping issue creation.') : console.log('An open issue referencing this PR already exists — skipping issue creation.');
            } else {
              const newIssue = await github.rest.issues.create({
                owner, repo, title, body, labels: ['review-changes','post-merge']
              });
              (core && core.info) ? core.info(`Created issue #${newIssue.data.number}`) : console.log(`Created issue #${newIssue.data.number}`);
            }

            // Trigger Jenkins build
            let fetchImpl = globalThis.fetch;
            if (!fetchImpl) {
              try { fetchImpl = require('node-fetch'); } catch(e) { fetchImpl = null; }
            }
            if (!fetchImpl) {
              (core && core.warning) ? core.warning('No fetch available to trigger Jenkins; skipping Jenkins trigger.') : console.warn('No fetch available to trigger Jenkins; skipping Jenkins trigger.');
              return;
            }

            const jenkinsUrl = process.env.JENKINS_URL;
            const jenkinsUser = process.env.JENKINS_USER;
            const jenkinsToken = process.env.JENKINS_API_TOKEN;
            const jobName = process.env.JENKINS_JOB_NAME;
            const paramsJson = process.env.JENKINS_BUILD_PARAMS_JSON || '';

            if (!jenkinsUrl || !jenkinsUser || !jenkinsToken || !jobName) {
              (core && core.warning) ? core.warning('Jenkins secrets not set; skipping Jenkins trigger.') : console.warn('Jenkins secrets not set; skipping Jenkins trigger.');
              return;
            }

            const auth = Buffer.from(`${jenkinsUser}:${jenkinsToken}`).toString('base64');
            let crumbHeader = {};
            try {
              const crumbResp = await fetchImpl(`${jenkinsUrl.replace(/\/+$/,'')}/crumbIssuer/api/json`, {
                headers: { 'Authorization': `Basic ${auth}` },
              });
              if (crumbResp.ok) {
                const crumbData = await crumbResp.json();
                crumbHeader[crumbData.crumbRequestField] = crumbData.crumb;
              }
            } catch (e) {
              (core && core.info) ? core.info('Could not fetch Jenkins crumb (maybe CSRF disabled) — continuing.') : console.log('Could not fetch Jenkins crumb (maybe CSRF disabled) — continuing.');
            }

            const triggerBase = `${jenkinsUrl.replace(/\/+$/,'')}/job/${encodeURIComponent(jobName)}`;
            const triggerEndpoint = paramsJson ? `${triggerBase}/buildWithParameters` : `${triggerBase}/build`;

            let triggerUrl = triggerEndpoint;
            if (paramsJson) {
              let params;
              try {
                params = JSON.parse(paramsJson);
              } catch (e) {
                (core && core.warning) ? core.warning('Invalid JENKINS_BUILD_PARAMS_JSON; skipping params.') : console.warn('Invalid JENKINS_BUILD_PARAMS_JSON; skipping params.');
                params = {};
              }
              params.PR_NUMBER = pr.number;
              params.PR_MERGED_BY = mergedByLogin;
              const qs = new URLSearchParams(params).toString();
              triggerUrl = `${triggerEndpoint}?${qs}`;
            }

            (core && core.info) ? core.info(`Triggering Jenkins: ${triggerUrl}`) : console.log(`Triggering Jenkins: ${triggerUrl}`);
            const resp = await fetchImpl(triggerUrl, {
              method: 'POST',
              headers: {
                'Authorization': `Basic ${auth}`,
                ...crumbHeader
              }
            });

            if (resp.ok || resp.status === 201 || resp.status === 200 || resp.status === 302) {
              (core && core.info) ? core.info('Jenkins build triggered successfully.') : console.log('Jenkins build triggered successfully.');
            } else {
              const text = await resp.text();
              (core && core.warning) ? core.warning(`Jenkins trigger returned status ${resp.status}: ${text}`) : console.warn(`Jenkins trigger returned status ${resp.status}: ${text}`);
            }
        env:
          JENKINS_URL: ${{ secrets.JENKINS_URL }}
          JENKINS_USER: ${{ secrets.JENKINS_USER }}
          JENKINS_API_TOKEN: ${{ secrets.JENKINS_API_TOKEN }}
          JENKINS_JOB_NAME: ${{ secrets.JENKINS_JOB_NAME }}
          JENKINS_BUILD_PARAMS_JSON: ${{ secrets.JENKINS_BUILD_PARAMS_JSON }}
